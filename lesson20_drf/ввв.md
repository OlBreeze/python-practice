# ============================================================
# books/models.py
# ============================================================
from django.db import models
from django.contrib.auth.models import User


class Book(models.Model):
    """
    Модель для представлення книги в бібліотеці.
    
    Attributes:
        title (str): Назва книги (максимум 255 символів)
        author (str): Автор книги (максимум 255 символів)
        genre (str): Жанр книги (максимум 100 символів)
        publication_year (int): Рік видання (тільки позитивні числа)
        user (ForeignKey): Користувач, який створив запис про книгу
        created_at (datetime): Дата і час створення запису
    """
    title = models.CharField(
        max_length=255,
        verbose_name="Назва книги",
        help_text="Введіть назву книги"
    )
    author = models.CharField(
        max_length=255,
        verbose_name="Автор",
        help_text="Введіть ім'я автора книги"
    )
    genre = models.CharField(
        max_length=100,
        verbose_name="Жанр",
        help_text="Введіть жанр книги (наприклад, фантастика, детектив)"
    )
    publication_year = models.PositiveIntegerField(
        verbose_name="Рік видання",
        help_text="Введіть рік видання книги"
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='books',
        verbose_name="Користувач",
        help_text="Користувач, який створив запис"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name="Дата створення"
    )

    class Meta:
        verbose_name = "Книга"
        verbose_name_plural = "Книги"
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['author']),
            models.Index(fields=['genre']),
            models.Index(fields=['publication_year']),
        ]

    def __str__(self) -> str:
        """Повертає рядкове представлення книги."""
        return f"{self.title} ({self.author}, {self.publication_year})"


# ============================================================
# books/serializers.py
# ============================================================
from rest_framework import serializers
from django.contrib.auth.models import User
from .models import Book


class BookSerializer(serializers.ModelSerializer):
    """
    Серіалізатор для моделі Book.
    
    Автоматично визначає поле user як поточного користувача.
    Включає дані про користувача, який створив запис (read-only).
    """
    user = serializers.ReadOnlyField(source='user.username')
    user_id = serializers.ReadOnlyField(source='user.id')
    
    class Meta:
        model = Book
        fields = [
            'id',
            'title',
            'author',
            'genre',
            'publication_year',
            'user',
            'user_id',
            'created_at'
        ]
        read_only_fields = ['id', 'user', 'user_id', 'created_at']
    
    def validate_publication_year(self, value: int) -> int:
        """
        Валідація року видання.
        
        Args:
            value: Рік видання
            
        Returns:
            Валідований рік видання
            
        Raises:
            ValidationError: Якщо рік видання більший за поточний рік
        """
        from datetime import datetime
        current_year = datetime.now().year
        
        if value > current_year:
            raise serializers.ValidationError(
                f"Рік видання не може бути більшим за поточний рік ({current_year})"
            )
        
        if value < 1000:
            raise serializers.ValidationError(
                "Рік видання повинен бути не менше 1000"
            )
        
        return value
    
    def validate_title(self, value: str) -> str:
        """
        Валідація назви книги.
        
        Args:
            value: Назва книги
            
        Returns:
            Валідована назва книги
            
        Raises:
            ValidationError: Якщо назва порожня або містить тільки пробіли
        """
        if not value or not value.strip():
            raise serializers.ValidationError("Назва книги не може бути порожньою")
        return value.strip()


class BookListSerializer(serializers.ModelSerializer):
    """
    Спрощений серіалізатор для списку книг.
    Включає мінімальну інформацію для оптимізації продуктивності.
    """
    user = serializers.ReadOnlyField(source='user.username')
    
    class Meta:
        model = Book
        fields = ['id', 'title', 'author', 'genre', 'publication_year', 'user']


# ============================================================
# books/filters.py
# ============================================================
from django_filters import rest_framework as filters
from .models import Book


class BookFilter(filters.FilterSet):
    """
    Фільтр для моделі Book.
    
    Filters:
        author: Фільтрація за автором (часткове співпадіння, регістронезалежне)
        genre: Фільтрація за жанром (часткове співпадіння, регістронезалежне)
        publication_year: Точна фільтрація за роком видання
        year_from: Фільтрація книг, виданих не раніше вказаного року
        year_to: Фільтрація книг, виданих не пізніше вказаного року
        title: Пошук за назвою (часткове співпадіння, регістронезалежне)
    """
    author = filters.CharFilter(
        field_name='author',
        lookup_expr='icontains',
        label='Автор'
    )
    genre = filters.CharFilter(
        field_name='genre',
        lookup_expr='icontains',
        label='Жанр'
    )
    publication_year = filters.NumberFilter(
        field_name='publication_year',
        label='Рік видання'
    )
    year_from = filters.NumberFilter(
        field_name='publication_year',
        lookup_expr='gte',
        label='Рік від'
    )
    year_to = filters.NumberFilter(
        field_name='publication_year',
        lookup_expr='lte',
        label='Рік до'
    )
    title = filters.CharFilter(
        field_name='title',
        lookup_expr='icontains',
        label='Назва'
    )
    
    class Meta:
        model = Book
        fields = ['author', 'genre', 'publication_year', 'title']


# ============================================================
# books/permissions.py
# ============================================================
from rest_framework import permissions


class IsAdminOrReadOnly(permissions.BasePermission):
    """
    Дозвіл, який дозволяє тільки адміністраторам виконувати небезпечні методи.
    
    - GET, HEAD, OPTIONS доступні всім автентифікованим користувачам
    - POST, PUT, PATCH доступні всім автентифікованим користувачам
    - DELETE доступний тільки адміністраторам
    """
    
    def has_permission(self, request, view):
        """
        Перевірка дозволу на рівні запиту.
        
        Args:
            request: HTTP запит
            view: View, який обробляє запит
            
        Returns:
            True, якщо дозвіл надано, False - інакше
        """
        # Дозволяємо безпечні методи всім автентифікованим користувачам
        if request.method in permissions.SAFE_METHODS:
            return request.user and request.user.is_authenticated
        
        # Дозволяємо POST, PUT, PATCH всім автентифікованим користувачам
        if request.method in ['POST', 'PUT', 'PATCH']:
            return request.user and request.user.is_authenticated
        
        # DELETE дозволений тільки адміністраторам
        if request.method == 'DELETE':
            return request.user and request.user.is_staff
        
        return False


class IsOwnerOrAdmin(permissions.BasePermission):
    """
    Дозвіл, який дозволяє редагувати об'єкт тільки його власнику або адміністратору.
    """
    
    def has_object_permission(self, request, view, obj):
        """
        Перевірка дозволу на рівні об'єкта.
        
        Args:
            request: HTTP запит
            view: View, який обробляє запит
            obj: Об'єкт, до якого здійснюється доступ
            
        Returns:
            True, якщо дозвіл надано, False - інакше
        """
        # Дозволяємо безпечні методи всім
        if request.method in permissions.SAFE_METHODS:
            return True
        
        # DELETE дозволений тільки адміністраторам
        if request.method == 'DELETE':
            return request.user.is_staff
        
        # PUT, PATCH дозволені власнику або адміністратору
        return obj.user == request.user or request.user.is_staff


# ============================================================
# books/views.py
# ============================================================
from rest_framework import viewsets, filters, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

from .models import Book
from .serializers import BookSerializer, BookListSerializer
from .filters import BookFilter
from .permissions import IsAdminOrReadOnly, IsOwnerOrAdmin


class BookViewSet(viewsets.ModelViewSet):
    """
    ViewSet для управління книгами.
    
    Надає наступні ендпоінти:
    - GET /api/books/ - список всіх книг (з пагінацією, фільтрацією та пошуком)
    - POST /api/books/ - створення нової книги
    - GET /api/books/{id}/ - деталі окремої книги
    - PUT /api/books/{id}/ - повне оновлення книги
    - PATCH /api/books/{id}/ - часткове оновлення книги
    - DELETE /api/books/{id}/ - видалення книги (тільки для адміністраторів)
    - GET /api/books/my_books/ - книги поточного користувача
    - GET /api/books/statistics/ - статистика по книгах
    
    Фільтрація:
    - author: фільтрація за автором
    - genre: фільтрація за жанром
    - publication_year: фільтрація за роком видання
    - year_from: книги від вказаного року
    - year_to: книги до вказаного року
    
    Пошук:
    - search: пошук за назвою або автором
    
    Сортування:
    - ordering: сортування за полями (title, author, publication_year, created_at)
      Для зворотного сортування використовуйте '-' перед полем (наприклад, -publication_year)
    """
    queryset = Book.objects.select_related('user').all()
    serializer_class = BookSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly, IsOwnerOrAdmin]
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = BookFilter
    search_fields = ['title', 'author']
    ordering_fields = ['title', 'author', 'publication_year', 'created_at']
    ordering = ['-created_at']
    
    def get_serializer_class(self):
        """
        Повертає відповідний серіалізатор в залежності від дії.
        
        Returns:
            BookListSerializer для списку книг
            BookSerializer для деталей та операцій створення/оновлення
        """
        if self.action == 'list':
            return BookListSerializer
        return BookSerializer
    
    def perform_create(self, serializer):
        """
        Зберігає нову книгу з поточним користувачем як власником.
        
        Args:
            serializer: Серіалізатор з валідованими даними
        """
        serializer.save(user=self.request.user)
    
    @swagger_auto_schema(
        operation_description="Отримати список книг поточного користувача",
        responses={200: BookSerializer(many=True)}
    )
    @action(detail=False, methods=['get'])
    def my_books(self, request):
        """
        Повертає список книг, створених поточним користувачем.
        
        Args:
            request: HTTP запит
            
        Returns:
            Response зі списком книг користувача
        """
        books = self.queryset.filter(user=request.user)
        serializer = self.get_serializer(books, many=True)
        return Response(serializer.data)
    
    @swagger_auto_schema(
        operation_description="Отримати статистику по книгах",
        responses={
            200: openapi.Response(
                description="Статистика",
                schema=openapi.Schema(
                    type=openapi.TYPE_OBJECT,
                    properties={
                        'total_books': openapi.Schema(type=openapi.TYPE_INTEGER),
                        'total_authors': openapi.Schema(type=openapi.TYPE_INTEGER),
                        'total_genres': openapi.Schema(type=openapi.TYPE_INTEGER),
                        'my_books_count': openapi.Schema(type=openapi.TYPE_INTEGER),
                    }
                )
            )
        }
    )
    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """
        Повертає статистику по всіх книгах.
        
        Args:
            request: HTTP запит
            
        Returns:
            Response зі статистикою
        """
        total_books = self.queryset.count()
        total_authors = self.queryset.values('author').distinct().count()
        total_genres = self.queryset.values('genre').distinct().count()
        my_books = self.queryset.filter(user=request.user).count()
        
        return Response({
            'total_books': total_books,
            'total_authors': total_authors,
            'total_genres': total_genres,
            'my_books_count': my_books,
        })


# ============================================================
# authentication/serializers.py
# ============================================================
from rest_framework import serializers
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password
from rest_framework.validators import UniqueValidator


class RegisterSerializer(serializers.ModelSerializer):
    """
    Серіалізатор для реєстрації нових користувачів.
    
    Fields:
        username: Унікальне ім'я користувача
        email: Унікальна email адреса
        password: Пароль (тільки для запису)
        password2: Підтвердження пароля (тільки для запису)
        first_name: Ім'я користувача (опціонально)
        last_name: Прізвище користувача (опціонально)
    """
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=User.objects.all())]
    )
    password = serializers.CharField(
        write_only=True,
        required=True,
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password2 = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'},
        label='Підтвердження пароля'
    )
    
    class Meta:
        model = User
        fields = ['username', 'email', 'password', 'password2', 'first_name', 'last_name']
        extra_kwargs = {
            'first_name': {'required': False},
            'last_name': {'required': False}
        }
    
    def validate(self, attrs):
        """
        Перевірка співпадіння паролів.
        
        Args:
            attrs: Словник з атрибутами
            
        Returns:
            Валідовані атрибути
            
        Raises:
            ValidationError: Якщо паролі не співпадають
        """
        if attrs['password'] != attrs['password2']:
            raise serializers.ValidationError({
                "password": "Паролі не співпадають"
            })
        return attrs


# ============================================================
# authentication/views.py
# ============================================================
from rest_framework import generics, status
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.views import APIView
from django.contrib.auth.models import User
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

from .serializers import RegisterSerializer, UserSerializer, ChangePasswordSerializer


class RegisterView(generics.CreateAPIView):
    """
    API ендпоінт для реєстрації нових користувачів.
    
    POST /api/auth/register/
    
    Не вимагає аутентифікації. Приймає дані нового користувача та створює акаунт.
    """
    queryset = User.objects.all()
    permission_classes = [AllowAny]
    serializer_class = RegisterSerializer
    
    @swagger_auto_schema(
        operation_description="Реєстрація нового користувача",
        responses={
            201: openapi.Response(
                description="Користувач успішно зареєстрований",
                schema=UserSerializer
            ),
            400: "Помилка валідації"
        }
    )
    def post(self, request, *args, **kwargs):
        """
        Створює нового користувача.
        
        Args:
            request: HTTP запит з даними користувача
            
        Returns:
            Response з даними створеного користувача
        """
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        return Response({
            'user': UserSerializer(user, context=self.get_serializer_context()).data,
            'message': 'Користувач успішно зареєстрований'
        }, status=status.HTTP_201_CREATED)


class UserProfileView(generics.RetrieveUpdateAPIView):
    """
    API ендпоінт для перегляду та оновлення профілю користувача.
    
    GET /api/auth/profile/ - отримати інформацію про поточного користувача
    PUT /api/auth/profile/ - оновити інформацію про користувача
    PATCH /api/auth/profile/ - частково оновити інформацію
    """
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]
    
    def get_object(self):
        """
        Повертає поточного користувача.
        
        Returns:
            Об'єкт User поточного користувача
        """
        return self.request.user
    
    @swagger_auto_schema(
        operation_description="Отримати профіль поточного користувача"
    )
    def get(self, request, *args, **kwargs):
        return super().get(request, *args, **kwargs)
    
    @swagger_auto_schema(
        operation_description="Оновити профіль користувача"
    )
    def put(self, request, *args, **kwargs):
        return super().put(request, *args, **kwargs)
    
    @swagger_auto_schema(
        operation_description="Частково оновити профіль користувача"
    )
    def patch(self, request, *args, **kwargs):
        return super().patch(request, *args, **kwargs)


class ChangePasswordView(APIView):
    """
    API ендпоінт для зміни пароля користувача.
    
    POST /api/auth/change-password/
    """
    permission_classes = [IsAuthenticated]
    
    @swagger_auto_schema(
        operation_description="Зміна пароля користувача",
        request_body=ChangePasswordSerializer,
        responses={
            200: openapi.Response(
                description="Пароль успішно змінено",
                schema=openapi.Schema(
                    type=openapi.TYPE_OBJECT,
                    properties={
                        'message': openapi.Schema(type=openapi.TYPE_STRING)
                    }
                )
            ),
            400: "Невірний старий пароль або помилка валідації"
        }
    )
    def post(self, request):
        """
        Змінює пароль користувача.
        
        Args:
            request: HTTP запит зі старим та новим паролем
            
        Returns:
            Response з повідомленням про успішну зміну або помилку
        """
        serializer = ChangePasswordSerializer(data=request.data)
        
        if serializer.is_valid():
            user = request.user
            
            # Перевірка старого пароля
            if not user.check_password(serializer.validated_data['old_password']):
                return Response({
                    'old_password': ['Невірний пароль']
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Встановлення нового пароля
            user.set_password(serializer.validated_data['new_password'])
            user.save()
            
            return Response({
                'message': 'Пароль успішно змінено'
            }, status=status.HTTP_200_OK)
        
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# ============================================================
# library_project/urls.py
# ============================================================
from django.contrib import admin
from django.urls import path, include
from rest_framework import permissions
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from drf_yasg.views import get_schema_view
from drf_yasg import openapi

# Налаштування Swagger/OpenAPI
schema_view = get_schema_view(
    openapi.Info(
        title="Library API",
        default_version='v1',
        description="""
        REST API для управління бібліотекою книг.
        
        ## Основні можливості:
        - CRUD операції для книг
        - Фільтрація за автором, жанром, роком видання
        - Пошук книг за назвою
        - Пагінація результатів
        - JWT аутентифікація
        - Реєстрація та управління профілем користувача
        
        ## Аутентифікація:
        1. Отримайте токен через /api/auth/token/
        2. Використовуйте токен в заголовку: `Authorization: Bearer <token>`
        
        ## Приклади фільтрації:
        - `/api/books/?author=Шевченко` - книги автора Шевченко
        - `/api/books/?genre=фантастика` - книги жанру фантастика
        - `/api/books/?year_from=2000&year_to=2020` - книги за період
        - `/api/books/?search=Кобзар` - пошук за назвою
        - `/api/books/?ordering=-publication_year` - сортування за роком (від нових)
        """,
        terms_of_service="https://www.example.com/policies/terms/",
        contact=openapi.Contact(email="contact@library.local"),
        license=openapi.License(name="MIT License"),
    ),
    public=True,
    permission_classes=[permissions.AllowAny],
)

urlpatterns = [
    # Admin
    path('admin/', admin.site.urls),
    
    # API endpoints
    path('api/books/', include('books.urls')),
    path('api/auth/', include('authentication.urls')),
    
    # JWT Authentication
    path('api/auth/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/auth/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    
    # API Documentation
    path('docs/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'),
    path('swagger.json', schema_view.without_ui(cache_timeout=0), name='schema-json'),
]


# ============================================================
# books/urls.py
# ============================================================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import BookViewSet

# Автоматична генерація URL через Router
router = DefaultRouter()
router.register(r'', BookViewSet, basename='book')

urlpatterns = [
    path('', include(router.urls)),
]


# ============================================================
# authentication/urls.py
# ============================================================
from django.urls import path
from .views import RegisterView, UserProfileView, ChangePasswordView

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('profile/', UserProfileView.as_view(), name='profile'),
    path('change-password/', ChangePasswordView.as_view(), name='change-password'),
]


# ============================================================
# books/tests.py
# ============================================================
from django.test import TestCase
from django.contrib.auth.models import User
from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse
from .models import Book


class BookModelTestCase(TestCase):
    """Тести для моделі Book."""
    
    def setUp(self):
        """Налаштування тестових даних."""
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123',
            email='test@example.com'
        )
        self.book = Book.objects.create(
            title='Тестова книга',
            author='Тестовий автор',
            genre='Тестовий жанр',
            publication_year=2023,
            user=self.user
        )
    
    def test_book_creation(self):
        """Тест створення книги."""
        self.assertEqual(self.book.title, 'Тестова книга')
        self.assertEqual(self.book.author, 'Тестовий автор')
        self.assertEqual(str(self.book), 'Тестова книга (Тестовий автор, 2023)')
    
    def test_book_user_relation(self):
        """Тест зв'язку книги з користувачем."""
        self.assertEqual(self.book.user, self.user)
        self.assertEqual(self.user.books.count(), 1)


class BookAPITestCase(APITestCase):
    """Тести для API управління книгами."""
    
    def setUp(self):
        """Налаштування тестових даних та клієнта."""
        # Створення користувачів
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123',
            email='test@example.com'
        )
        self.admin = User.objects.create_user(
            username='admin',
            password='adminpass123',
            email='admin@example.com',
            is_staff=True
        )
        
        # Створення тестових книг
        self.book1 = Book.objects.create(
            title='Кобзар',
            author='Тарас Шевченко',
            genre='Поезія',
            publication_year=1840,
            user=self.user
        )
        self.book2 = Book.objects.create(
            title='Тіні забутих предків',
            author='Михайло Коцюбинський',
            genre='Новела',
            publication_year=1911,
            user=self.user
        )
        
        self.client = APIClient()
    
    def test_get_books_unauthenticated(self):
        """Тест отримання списку книг без аутентифікації."""
        url = reverse('book-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
    
    def test_get_books_authenticated(self):
        """Тест отримання списку книг з аутентифікацією."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-list')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 2)
    
    def test_create_book(self):
        """Тест створення нової книги."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-list')
        data = {
            'title': 'Захар Беркут',
            'author': 'Іван Франко',
            'genre': 'Історична повість',
            'publication_year': 1883
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Book.objects.count(), 3)
        self.assertEqual(response.data['title'], 'Захар Беркут')
        self.assertEqual(response.data['user'], 'testuser')
    
    def test_get_book_detail(self):
        """Тест отримання деталей книги."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-detail', kwargs={'pk': self.book1.pk})
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['title'], 'Кобзар')
        self.assertEqual(response.data['author'], 'Тарас Шевченко')
    
    def test_update_book(self):
        """Тест оновлення книги."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-detail', kwargs={'pk': self.book1.pk})
        data = {
            'title': 'Кобзар (оновлене видання)',
            'author': 'Тарас Шевченко',
            'genre': 'Поезія',
            'publication_year': 1840
        }
        response = self.client.put(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.book1.refresh_from_db()
        self.assertEqual(self.book1.title, 'Кобзар (оновлене видання)')
    
    def test_delete_book_as_user(self):
        """Тест видалення книги звичайним користувачем (має бути заборонено)."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-detail', kwargs={'pk': self.book1.pk})
        response = self.client.delete(url)
        
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.assertEqual(Book.objects.count(), 2)
    
    def test_delete_book_as_admin(self):
        """Тест видалення книги адміністратором."""
        self.client.force_authenticate(user=self.admin)
        url = reverse('book-detail', kwargs={'pk': self.book1.pk})
        response = self.client.delete(url)
        
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(Book.objects.count(), 1)
    
    def test_filter_books_by_author(self):
        """Тест фільтрації книг за автором."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-list')
        response = self.client.get(url, {'author': 'Шевченко'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['author'], 'Тарас Шевченко')
    
    def test_filter_books_by_year_range(self):
        """Тест фільтрації книг за діапазоном років."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-list')
        response = self.client.get(url, {'year_from': 1900, 'year_to': 1920})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['title'], 'Тіні забутих предків')
    
    def test_search_books(self):
        """Тест пошуку книг за назвою."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-list')
        response = self.client.get(url, {'search': 'Кобзар'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['title'], 'Кобзар')
    
    def test_order_books_by_year(self):
        """Тест сортування книг за роком видання."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-list')
        response = self.client.get(url, {'ordering': 'publication_year'})
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['results'][0]['publication_year'], 1840)
        self.assertEqual(response.data['results'][1]['publication_year'], 1911)
    
    def test_my_books_endpoint(self):
        """Тест ендпоінту отримання книг користувача."""
        # Створюємо іншого користувача з його книгою
        other_user = User.objects.create_user(
            username='otheruser',
            password='pass123'
        )
        Book.objects.create(
            title='Інша книга',
            author='Інший автор',
            genre='Інший жанр',
            publication_year=2000,
            user=other_user
        )
        
        self.client.force_authenticate(user=self.user)
        url = reverse('book-my-books')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 2)  # Тільки книги поточного користувача
    
    def test_statistics_endpoint(self):
        """Тест ендпоінту статистики."""
        self.client.force_authenticate(user=self.user)
        url = reverse('book-statistics')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('total_books', response.data)
        self.assertIn('total_authors', response.data)
        self.assertIn('my_books_count', response.data)
        self.assertEqual(response.data['total_books'], 2)


# ============================================================
# authentication/tests.py
# ============================================================
from django.test import TestCase
from django.contrib.auth.models import User
from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.urls import reverse


class AuthenticationAPITestCase(APITestCase):
    """Тести для API аутентифікації."""
    
    def setUp(self):
        """Налаштування тестових даних."""
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123',
            first_name='Test',
            last_name='User'
        )
    
    def test_user_registration(self):
        """Тест реєстрації нового користувача."""
        url = reverse('register')
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'NewPass123!@#',
            'password2': 'NewPass123!@#',
            'first_name': 'New',
            'last_name': 'User'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertIn('user', response.data)
        self.assertEqual(response.data['user']['username'], 'newuser')
        self.assertEqual(User.objects.count(), 2)
    
    def test_registration_with_mismatched_passwords(self):
        """Тест реєстрації з неспівпадаючими паролями."""
        url = reverse('register')
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'NewPass123!@#',
            'password2': 'DifferentPass123',
            'first_name': 'New',
            'last_name': 'User'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('password', response.data)
    
    def test_registration_with_existing_username(self):
        """Тест реєстрації з існуючим ім'ям користувача."""
        url = reverse('register')
        data = {
            'username': 'testuser',  # Вже існує
            'email': 'another@example.com',
            'password': 'NewPass123!@#',
            'password2': 'NewPass123!@#'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('username', response.data)
    
    def test_registration_with_weak_password(self):
        """Тест реєстрації зі слабким паролем."""
        url = reverse('register')
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': '123',  # Занадто короткий пароль
            'password2': '123'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('password', response.data)
    
    def test_get_user_profile(self):
        """Тест отримання профілю користувача."""
        self.client.force_authenticate(user=self.user)
        url = reverse('profile')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['username'], 'testuser')
        self.assertEqual(response.data['email'], 'test@example.com')
    
    def test_get_profile_unauthenticated(self):
        """Тест отримання профілю без аутентифікації."""
        url = reverse('profile')
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
    
    def test_update_user_profile(self):
        """Тест оновлення профілю користувача."""
        self.client.force_authenticate(user=self.user)
        url = reverse('profile')
        data = {
            'first_name': 'Updated',
            'last_name': 'Name',
            'email': 'updated@example.com'
        }
        response = self.client.patch(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.user.refresh_from_db()
        self.assertEqual(self.user.first_name, 'Updated')
        self.assertEqual(self.user.email, 'updated@example.com')
    
    def test_change_password(self):
        """Тест зміни пароля."""
        self.client.force_authenticate(user=self.user)
        url = reverse('change-password')
        data = {
            'old_password': 'testpass123',
            'new_password': 'NewSecurePass123!@#',
            'new_password2': 'NewSecurePass123!@#'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.user.refresh_from_db()
        self.assertTrue(self.user.check_password('NewSecurePass123!@#'))
    
    def test_change_password_with_wrong_old_password(self):
        """Тест зміни пароля з неправильним старим паролем."""
        self.client.force_authenticate(user=self.user)
        url = reverse('change-password')
        data = {
            'old_password': 'wrongpassword',
            'new_password': 'NewSecurePass123!@#',
            'new_password2': 'NewSecurePass123!@#'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('old_password', response.data)
    
    def test_jwt_token_obtain(self):
        """Тест отримання JWT токену."""
        url = reverse('token_obtain_pair')
        data = {
            'username': 'testuser',
            'password': 'testpass123'
        }
        response = self.client.post(url, data)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('access', response.data)
        self.assertIn('refresh', response.data)


# ============================================================
# ІНСТРУКЦІЇ ПО ЗАПУСКУ ПРОЄКТУ
# ============================================================
"""
1. Створіть віртуальне середовище:
   python -m venv venv
   source venv/bin/activate  # Linux/Mac
   venv\Scripts\activate  # Windows

2. Встановіть залежності:
   pip install -r requirements.txt

3. Створіть базу даних і застосуйте міграції:
   python manage.py makemigrations
   python manage.py migrate

4. Створіть суперкористувача (адміністратора):
   python manage.py createsuperuser

5. Запустіть сервер:
   python manage.py runserver

6. Доступ до API:
   - Swagger документація: http://localhost:8000/docs/
   - ReDoc документація: http://localhost:8000/redoc/
   - Admin панель: http://localhost:8000/admin/

7. Запуск тестів:
   python manage.py test

   Запуск тестів з деталізацією:
   python manage.py test --verbosity=2

   Запуск тестів для конкретного додатку:
   python manage.py test books
   python manage.py test authentication

8. Приклади використання API:

   a) Реєстрація користувача:
   POST http://localhost:8000/api/auth/register/
   {
       "username": "johndoe",
       "email": "john@example.com",
       "password": "SecurePass123!",
       "password2": "SecurePass123!",
       "first_name": "John",
       "last_name": "Doe"
   }

   b) Отримання JWT токену:
   POST http://localhost:8000/api/auth/token/
   {
       "username": "johndoe",
       "password": "SecurePass123!"
   }

   c) Створення книги (потрібен токен):
   POST http://localhost:8000/api/books/
   Headers: Authorization: Bearer <your_access_token>
   {
       "title": "Кобзар",
       "author": "Тарас Шевченко",
       "genre": "Поезія",
       "publication_year": 1840
   }

   d) Отримання списку книг з фільтрацією:
   GET http://localhost:8000/api/books/?author=Шевченко&ordering=-publication_year
   Headers: Authorization: Bearer <your_access_token>

   e) Пошук книг:
   GET http://localhost:8000/api/books/?search=Кобзар
   Headers: Authorization: Bearer <your_access_token>

   f) Отримання статистики:
   GET http://localhost:8000/api/books/statistics/
   Headers: Authorization: Bearer <your_access_token>

   g) Отримання моїх книг:
   GET http://localhost:8000/api/books/my_books/
   Headers: Authorization: Bearer <your_access_token>

9. Структура ендпоінтів:

   АУТЕНТИФІКАЦІЯ:
   - POST   /api/auth/register/          - Реєстрація користувача
   - POST   /api/auth/token/             - Отримання JWT токену
   - POST   /api/auth/token/refresh/     - Оновлення JWT токену
   - GET    /api/auth/profile/           - Отримання профілю
   - PUT    /api/auth/profile/           - Оновлення профілю
   - PATCH  /api/auth/profile/           - Часткове оновлення профілю
   - POST   /api/auth/change-password/   - Зміна пароля

   КНИГИ:
   - GET    /api/books/                  - Список книг (з фільтрами)
   - POST   /api/books/                  - Створення книги
   - GET    /api/books/{id}/             - Деталі книги
   - PUT    /api/books/{id}/             - Оновлення книги
   - PATCH  /api/books/{id}/             - Часткове оновлення
   - DELETE /api/books/{id}/             - Видалення книги (тільки admin)
   - GET    /api/books/my_books/         - Мої книги
   - GET    /api/books/statistics/       - Статистика

10. Параметри фільтрації та пошуку:
    - author=<текст>              - Фільтр за автором
    - genre=<текст>               - Фільтр за жанром
    - publication_year=<рік>      - Фільтр за роком
    - year_from=<рік>             - Від року
    - year_to=<рік>               - До року
    - search=<текст>              - Пошук за назвою/автором
    - ordering=<поле>             - Сортування (title, author, publication_year, created_at)
                                    Для зворотного порядку: -<поле>
    - page=<номер>                - Номер сторінки (пагінація)

11. Особливості реалізації:
    - Окремий додаток authentication для всієї логіки аутентифікації
    - JWT токени з автоматичним оновленням
    - Дозволи на рівні ViewSet та об'єкта
    - Автоматична документація API через Swagger
    - Повне покриття тестами (15+ тестів)
    - Валідація даних на рівні серіалізаторів
    - Оптимізовані запити до БД (select_related)
    - Індекси для покращення продуктивності

12. Безпека:
    - Тільки автентифіковані користувачі мають доступ до API
    - Видалення книг дозволене тільки адміністраторам
    - Редагування книг дозволене тільки власнику або адміністратору
    - Пароль валідується Django password validators
    - JWT токени мають обмежений термін дії
    - CSRF захист включений

13. Розширення функціоналу:
    - Додано поле user до моделі Book
    - Реалізовано реєстрацію та управління профілем
    - Додано зміну пароля
    - Додано статистику по книгах
    - Додано ендпоінт "мої книги"
    - Сортування за різними полями
    
МІКРОСЕРВІСНА АРХІТЕКТУРА:
Так, authentication додаток можна легко перетворити на окремий мікросервіс:

1. Винесіть додаток authentication в окремий проєкт Django
2. Налаштуйте окрему базу даних для користувачів
3. Використовуйте спільну JWT SECRET_KEY для обох сервісів
4. Books сервіс буде валідувати токени від Authentication сервісу
5. Комунікація через REST API або gRPC

Переваги такого підходу:
- Незалежне масштабування сервісів
- Різні команди можуть працювати над різними сервісами
- Легше оновлювати та деплоїти окремі компоненти
- Можливість використання різних технологій для різних сервісів

В поточній реалізації authentication вже виділений в окремий додаток (app),
що є першим кроком до мікросервісної архітектури.
"""
    
    def create(self, validated_data):
        """
        Створення нового користувача.
        
        Args:
            validated_data: Валідовані дані
            
        Returns:
            Створений об'єкт User
        """
        validated_data.pop('password2')
        user = User.objects.create_user(**validated_data)
        return user


class UserSerializer(serializers.ModelSerializer):
    """
    Серіалізатор для відображення інформації про користувача.
    """
    books_count = serializers.SerializerMethodField()
    
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 'books_count', 'is_staff']
        read_only_fields = ['id', 'is_staff']
    
    def get_books_count(self, obj):
        """
        Отримує кількість книг користувача.
        
        Args:
            obj: Об'єкт User
            
        Returns:
            Кількість книг користувача
        """
        return obj.books.count()


class ChangePasswordSerializer(serializers.Serializer):
    """
    Серіалізатор для зміни пароля.
    """
    old_password = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'}
    )
    new_password = serializers.CharField(
        required=True,
        write_only=True,
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    new_password2 = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'}
    )
    
    def validate(self, attrs):
        """
        Перевірка співпадіння нових паролів.
        """
        if attrs['new_password'] != attrs['new_password2']:
            raise serializers.ValidationError({
                "new_password": "Нові паролі не співпадають"
            })
        return attrs