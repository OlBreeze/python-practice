import threading
import time  # Необхідний для реалістичного прикладу

Lock = threading.Lock()  # RLock()


def task():
    print('Потік намагається заблокувати Lock')
    Lock.acquire()
    print('Set Lock')

    # Цей рядок призведе до БЛОКУВАННЯ потоку, оскільки стандартний Lock
    # не є реентерабельним (тобто не може бути повторно захоплений тим самим потоком).
    print("Спроба повторного блокування...")
    Lock.acquire()

    print("Розблокування Lock")
    Lock.release()


# Створення та запуск потоку
t = threading.Thread(target=task)
t.start()

# Очікування завершення потоку (зауважте, що join() може ніколи не завершитися,
# оскільки Lock.acquire() на рядку 11 заблокує потік)
t.join()

#
# Стандартний об'єкт threading.Lock() є нереентерабельним. Це означає, що потік, який вже захопив блокування
# (Lock.acquire() на рядку 7), не може захопити його знову (рядок 11).
#
# На рядку 7 потік блокує Lock.
#
# На рядку 11 потік намагається повторно заблокувати Lock,
# але оскільки Lock вже захоплений цим же потоком, він блокується сам і чекає звільнення.
#
# Через це рядок 14 (Lock.release()) ніколи не буде досягнутий,
# і програма зупиниться, очікуючи вічно (дедлок).
#
# Для ситуацій, коли потрібно повторне блокування одним і тим самим потоком,
# використовують threading.RLock() (Reentrant Lock).
