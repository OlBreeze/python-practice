import threading
import time

# Створення семафора, який дозволяє лише 2 потокам працювати одночасно
# semaphore = threading.BoundedSemaphore(2) # ЦЕ ПРАВИЛЬНО!!!
semaphore = threading.Semaphore(2) # ЦЕ ПОМИЛКА!!!


def worker(n):
    print(f"Thread {n} is waiting...")
    semaphore.acquire()

    # Критична секція: тут працюють лише 2 потоки
    print(f"Thread {n} is working...")
    time.sleep(1)

    # Потік звільняє дозвіл
    semaphore.release()
    print(f"Thread {n} is done...")


# Створення 10 потоків
threads = [threading.Thread(target=worker, args=(i,)) for i in range(10)]

# Запуск потоків
for t in threads:
    t.start()

# Очікування завершення всіх потоків
for t in threads:
    t.join()

# !!! УВАГА: Це логічна помилка, яка може викликати ValueError !!!
# Ці два виклики збільшують лічильник семафора, коли він вже повинен бути 2.
# Якщо семафор використовується як лічильник, він може стати більшим за початкове значення.
semaphore.release()
semaphore.release()

print("Counter more than start value!")

#
# Основна проблема тут — це рядки semaphore.release() наприкінці основного потоку.
#
# Кожен потік worker викликає acquire() і release() один раз. Після завершення всіх 10 потоків лічильник семафора повернеться до свого початкового значення 2.
# Коли основний потік викликає semaphore.release() в кінці, він збільшує лічильник семафора до 3, а потім до 4.
#
# Це є некоректним використанням семафора. Хоча threading.Semaphore дозволяє лічильнику стати більшим за його початкове значення (2), цей код, ймовірно, був написаний як анти-приклад або для ілюстрації того, що семафор — це просто лічильник,
# який можна збільшувати. У реальній програмі це порушило б логіку контролю ресурсів.