
# Тестирование программного обеспечения в Python

**Повестка (Agenda):**

1. Введение в тестирование
2. Библиотеки для тестирования в Python
3. Создание unit-тестов с unittest
4. Глубокое тестирование с pytest
5. Мокинг и патчинг
6. Тестирование ошибок и неправильного поведения кода
7. Организация тестов: структура файлов в проекте
8. Практика
9. Статический анализ кода: линтеры (flake8 и pylint) и интеграция в процесс разработки
10. Выводы

---

## 1. Введение в тестирование

### Почему тестирование важно

Тестирование помогает обеспечить корректность, надёжность и стабильность кода. Оно позволяет выявлять ошибки на ранних этапах разработки, что снижает стоимость их исправления и повышает качество продукта. Без тестирования изменения в коде могут привести к непредвиденным ошибкам в других частях программы, что усложняет разработку и сопровождение.
Кроме того:

* Автоматизированные тесты дают уверенность при рефакторинге.
* Тесты могут служить документированием поведения компонентов.
* Тестовые сценарии помогают при интеграции и деплое.
  Также есть исследования, которые подчёркивают важность тестирования: например, в научном/исследовательском ПО одной из ключевых задач является обеспечение доверия к коду. ([arXiv][1])

### Виды тестирования

* **Unit-тесты (юнит-тесты):** проверка отдельных компонентов (функций, классов) кода. Пример: тестирование функции, вычисляющей факториал числа.
* **Интеграционные тесты:** проверка взаимодействия между несколькими модулями или компонентами. Пример: тестирование взаимодействия между базой данных и API.
* **Функциональные тесты:** проверка соответствия программного обеспечения требованиям и ожидаемому поведению с точки зрения пользователя. Пример: проверка регистрации пользователя на сайте.
  Также можно упомянуть: системные тесты, приёмочные тесты, нагрузочное тестирование и др., но в рамках данной лекции сосредоточимся на основных трёх.

### Преимущества автоматизированного тестирования

* **Экономия времени:** Автоматизированные тесты запускаются быстро и многократно, что позволяет проверить много сценариев без ручного вмешательства.
* **Повышение качества:** Систематическое тестирование снижает количество багов.
* **Безопасный рефакторинг:** Можно вносить изменения, уверенно зная, что тесты подскажут, если что-то сломано.
* **Документация:** Тесты сами по себе демонстрируют, как должен работать код.
* **Поддержка CI/CD:** Автоматизированные тесты легко интегрируются в процесс непрерывной интеграции/развертывания.

---

## 2. Библиотеки для тестирования в Python

В Python-экосистеме есть несколько библиотек и инструментов для тестирования:

* `unittest` — встроенная библиотека Python для создания unit-тестов.
* `pytest` — популярная внешняя библиотека с расширенными возможностями: более лаконичный синтаксис, фикстуры (fixtures), параметризация и богатая экосистема плагинов. ([GeeksforGeeks][2])
* `mock` / `unittest.mock` — библиотека для создания заглушек (mock-объектов) для зависимостей.
* Для интеграционных/функциональных тестов часто используют дополнительные библиотеки (requests, selenium, hypothesis и т.д.).
* Кроме того, инструменты статического анализа и линтинга (о них — ниже) помогают поддерживать качество кода.

---

## 3. Создание unit-тестов с `unittest`

Вот пример простого юнит-теста с использованием `unittest`:

```python
import unittest

def add(x, y):
    return x + y

class TestAdd(unittest.TestCase):
    def test_add_positive_numbers(self):
        self.assertEqual(add(2, 3), 5)

    def test_add_negative_numbers(self):
        self.assertEqual(add(-2, -3), -5)

if __name__ == '__main__':
    unittest.main()
```

Объяснения:

* Мы определяем функцию `add`, которая суммирует два числа.
* Создаём класс `TestAdd`, наследующий `unittest.TestCase`.
* В нём прописываем методы, начинающиеся с `test_`, которые проверяют ожидаемое поведение (с помощью `self.assertEqual`).
* Запускаем `unittest.main()` для выполнения тестов.

**Плюсы и минусы `unittest`:**

* Плюсы: входит в стандартную библиотеку — никаких внешних зависимостей.
* Минусы: требуется больше шаблонного (boilerplate) кода, чем более современные фреймворки. ([GeeksforGeeks][2])
* Хорош для простых проектов или когда хочется минимизировать внешние зависимости.

---

## 4. Глубокое тестирование с `pytest`

`pytest` предлагает более лёгкий и гибкий подход к тестированию. Пример того же функционала с `pytest`:

```python
def add(x, y):
    return x + y

def test_add_positive_numbers():
    assert add(2, 3) == 5

def test_add_negative_numbers():
    assert add(-2, -3) == -5
```

Запуск: просто команды `pytest` (он автоматически обнаружит файлы с именем `test_*.py` или `*_test.py`).

### Почему `pytest` выбирают многие команды

* Более лаконичный синтаксис: используется обычный `assert`, а не специальные методы `self.assert*`. ([Continuously Merging][3])
* Автоматическое обнаружение тестов без необходимости создания классов. ([BrowserStack][4])
* Сильная поддержка фикстур (fixtures), параметризации, множества плагинов. ([GeeksforGeeks][5])
* Совместимость с `unittest`: можно запускать существующие unittest-тесты с помощью pytest без переделки. ([Pytest Documentation][6])

### Пример использования фикстур

```python
import pytest

class Fruit:
    def __init__(self, name):
        self.name = name
        self.cubed = False
    def cube(self):
        self.cubed = True

class FruitSalad:
    def __init__(self, *fruit_bowl):
        self.fruit = fruit_bowl
        self._cube_fruit()
    def _cube_fruit(self):
        for fruit in self.fruit:
            fruit.cube()

@pytest.fixture
def fruit_bowl():
    return [Fruit("apple"), Fruit("banana")]

def test_fruit_salad(fruit_bowl):
    salad = FruitSalad(*fruit_bowl)
    assert all(f.cubed for f in salad.fruit)
```

Здесь фикстура `fruit_bowl` создаёт список фруктов, который затем используется в тесте. ([Pytest Documentation][7])

---

## 5. Мокинг и патчинг

Когда код зависит от внешних ресурсов (например, HTTP-API, БД, файловой системы), полезно заменить такие зависимости «заглушками» (mocks) или временно патчить поведение. Это позволяет тестировать код в изоляции.

Пример с использованием `unittest.mock`:

```python
from unittest.mock import patch
import requests

def get_data_from_api(url):
    response = requests.get(url)
    return response.json()

@patch('requests.get')
def test_get_data_from_api(mock_get):
    mock_get.return_value.json.return_value = {'key': 'value'}
    result = get_data_from_api('http://example.com/api')
    assert result == {'key': 'value'}
```

Здесь мы заменили `requests.get` на заглушку и задали её поведение.
Это позволяет тестировать `get_data_from_api` без реально обращения к сети.

При использовании `pytest` можно совместно использовать `unittest.mock` либо плагин `pytest-mock` (неактивируемый тут).
Мокинг помогает:

* Изолировать тестируемый компонент.
* Контролировать поведение зависимостей (например, возвращать ошибки, таймауты).
* Ускорить тесты, так как не нужно делать реальные сетевые вызовы, работать с внешними системами.

---

## 6. Тестирование ошибок и неправильного поведения кода

Важно не только проверять «хорошие» случаи, но и как код ведёт себя при ошибках, исключениях или нестандартных входных данных.

Пример с `pytest.raises`:

```python
import pytest

def divide(x, y):
    if y == 0:
        raise ZeroDivisionError("Cannot divide by zero")
    return x / y

def test_divide_by_zero():
    with pytest.raises(ZeroDivisionError):
        divide(10, 0)
```

Эта проверка удостоверяется, что при `y == 0` выбрасывается `ZeroDivisionError`.
Проблемные случаи могут включать:

* Неверные параметры (например, null/None, пустые строки).
* Исключения от зависимостей (например, БД отключена).
* Логические ошибки — например, неверный формат вводных данных.

Хорошая практика: проверять не только позитивные сценарии, но и негативные, крайние случаи и неверные входные данные.

---

## 7. Организация тестов: структура файлов в проекте

Поддерживаемая структура тестов помогает проекту легче развиваться, тесты легко находить и запускать.

Рекомендации:

* Создать каталог `tests/` рядом с основным кодом проекта.
* Файлы тестов именовать, например: `test_my_module.py` для `my_module.py`.
* Можно зеркалировать структуру папок основного кода внутри `tests/`.
* Разделять уровни тестов: unit-тесты (ближе к коду), интеграционные тесты (отдельная папка или пометка).
* Использовать конфигурации (например, файл `pytest.ini`) для настройки `pytest-discovery`.
* При больших проектах: группировка тестов по модулю/компоненту, использование фикстур для настройки общего состояния.

Пример структуры:

```
project/
│
├─ my_module.py
├─ other_module.py
│
└─ tests/
   ├─ test_my_module.py
   ├─ test_other_module.py
   └─ integration/
       ├─ test_api_database_integration.py
```

Также полезно интегрировать тесты в CI (например, GitHub Actions, GitLab CI) — чтобы при каждом коммите/PR автоматически запускались тесты.

---

## 8. Практика

Предлагаю выполнить несколько упражнений:

1. Написать функцию, например, `factorial(n)`, и покрыть её unit-тестами (позитивные случаи, ноль/отрицательные числа).
2. Создать модуль, который взаимодействует с внешним API (например, `requests.get`), и замокать этот вызов, тестируя поведение модуля при разных ответах.
3. Использовать `pytest` и фикстуры: например, фикстура создаёт временный файл или структуру данных, и тесты используют её.
4. Настроить запуск тестов через `pytest`, включая параметризацию (например, `@pytest.mark.parametrize`) и проверить отрицательные сценарии с `pytest.raises`.
5. Организовать каталог `tests/`, добавить интеграционный тест (например, между двумя модулями), и настроить `pytest.ini`.
6. (Дополнительно) Настроить линтеры и выполнить статический анализ перед запуском тестов (см. раздел далее).

---

## 9. Статический анализ кода (линтеры) и интеграция в процесс разработки

### Инструменты

* flake8 — инструмент для статического анализа кода: проверка стиля, ошибок форматирования, неиспользованных импортов.
* pylint — более «тяжёлый» инструмент, оценивающий качество кода, сложность, соответствие конвенциям, потенциальные баги.

### Почему это важно

Статический анализ помогает поддерживать кодовую базу чистой и понятной. Он выявляет:

* Неиспользуемые, устаревшие конструкции.
* Перегруженные функции и методы (слишком большая сложность).
* Нарушения стиля, которые могут повлиять на читаемость.
  Интеграция линтеров в процесс разработки повышает дисциплину и снижает технический долг.

### Интеграция в процесс разработки

* Запускать линтеры локально (например, `flake8 .`, `pylint my_module.py`) перед коммитом.
* Интегрировать в git-hook (`pre-commit`) — автоматический запуск перед коммитом.
* Включить в CI/CD пайплайн: каждая сборка проекта включает шаг «lint → тесты → анализ покрытия».
* Настроить порог допустимых ошибок (например, `pylint` score выше 9.0) или блокировать merge-request, если линтинг упал.

---

## 10. Выводы

* Тестирование — это не просто «дополнительная работа», а залог надёжности, масштабируемости и поддерживаемости кода.
* Начинать можно с `unittest`, но `pytest` даёт мощные возможности, меньше шаблонного кода и больше гибкости.
* Мокинг/патчинг позволяют изолировать тестируемые части и сделать тесты быстрыми и надёжными.
* Не забывайте тестировать негативные сценарии, ошибки и крайние случаи — это поможет предотвратить реальные дефекты.
* Организация тестов и интеграция в CI/CD — ключ к автоматизации и постоянному качеству.
* Помимо тестов: статический анализ (линтеры) помогает держать кодовую базу чистой и понятной.
* Регулярное выполнение тестов, их поддержка и расширение — залог успешного проекта.

---

Если хочешь, могу подготовить **слайды** по этой лекции или **шаблон проекта** с настройкой тестов и линтеров — желаешь?

[1]: https://arxiv.org/abs/2205.15982?utm_source=chatgpt.com "Testing Research Software: A Survey"
[2]: https://www.geeksforgeeks.org/difference-between-pytest-and-unittest/?utm_source=chatgpt.com "Difference between Pytest and Unittest - GeeksforGeeks"
[3]: https://blog.mergify.com/unittest-vs-pytest/?utm_source=chatgpt.com "Unittest vs Pytest: Which Python Testing Framework is Best?"
[4]: https://www.browserstack.com/guide/pytest-vs-unittest?utm_source=chatgpt.com "Pytest vs Unittest: A Comparison | BrowserStack"
[5]: https://www.geeksforgeeks.org/pytest-tutorial-testing-python-application-using-pytest/?utm_source=chatgpt.com "Pytest Tutorial - Unit Testing in Python using Pytest Framework - GeeksforGeeks"
[6]: https://docs.pytest.org/en/7.1.x/how-to/unittest.html?utm_source=chatgpt.com "How to use unittest-based tests with pytest — pytest documentation"
[7]: https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?utm_source=chatgpt.com "How to use fixtures — pytest documentation"
