# Архитектура программного обеспечения и Event-Driven Architecture

## Введение в архитектуру ПО

**Архитектура программного обеспечения** — это описание структуры проекта с определением взаимосвязей между элементами этой структуры.

При разработке любого проекта первый этап — это анализ идеи, формирование требований и выбор архитектуры. Нет универсального шаблона на все случаи жизни — выбор зависит от специфики задачи.

---

## Основные типы архитектур

### 1. Монолитная архитектура

**Особенности:**
- Система разрабатывается и развертывается как единый неделимый блок кода
- Все компоненты (UI, бизнес-логика, доступ к данным, авторизация, валидация) тесно связаны
- Работают как один процес
- Если одна часть не работает — не работает вся система

**Преимущества:**
- Простая реализация
- Быстрое создание MVP
- Простое тестирование и отладка
- Локальные вызовы функций
- Единая база кода
- Меньшие накладные расходы на инфраструктуру
- Нужен только один сервер

**Недостатки:**
- Медленное развертывание (изменение одного модуля требует перекомпиляции всего проекта)
- Масштабируется только вся система целиком
- Сложно менять технологии в рамках единого проекта
- Зависимость от технологического стека

**Где используется:**
- Стартапы и проверка гипотез (от 0 до 1)
- Небольшие и средние проекты
- Простые внутренние инструменты
- Проекты с ограниченным бюджетом

**Аналогия:** Как автомобиль — если одно колесо вышло из строя, ехать дальше невозможно.

---

### 2. Микросервисная архитектура

**Особенности:**
- Система разбивается на коллекцию небольших независимых сервисов
- Каждый сервис реализует одну бизнес-функцию
- Имеет собственную базу данных
- Взаимодействие через простые протоколы (API, брокеры сообщений)

**Преимущества:**
- Высокая масштабируемость (можно масштабировать только нагруженные сервисы)
- Каждый сервис может быть написан на подходящем языке/фреймворке
- Высокая стойкость к отказам (сбой одного сервиса не выводит из строя всю систему)
- Независимое развертывание
- Команды могут работать параллельно над разными сервисами

**Недостатки:**
- Сложные инструменты для мониторинга, логирования и оркестрации (обычно используется Kubernetes)
- Сложность распределенных транзакций (нужно обеспечить целостность данных между разными БД)
- Высокие накладные расходы на сетевую коммуникацию
- Возможны задержки API-вызовов

**Где используется:**
- Сложные большие системы
- E-commerce платформы
- SaaS решения
- Банковские системы
- Проекты с высокими требованиями к отказоустойчивости
- Команды, распределенные по доменам

**Аналогия:** Как грузовик с прицепом на нескольких осях — если одно колесо вышло из строя, можно доехать до сервиса на запасной оси.

---

### 3. Многослойная архитектура (Layered Architecture)

**Особенности:**
- Система разделена на горизонтальные слои
- Каждый слой имеет четкую ответственность
- Взаимодействие односторонне: слой может вызывать только функции слоя, расположенного непосредственно под ним

**Типичные слои:**
1. **Presentation Layer** (уровень представления) — UI
2. **Business Layer** (бизнес-логика)
3. **Data Access Layer** (доступ к данным)
4. Дополнительные слои по необходимости

**Преимущества:**
- Структурированность и четкое разделение ответственности
- Легкость тестирования (каждый слой можно тестировать изолированно с моками)
- Хорошая поддерживаемость

**Недостатки:**
- Layer jumping: запрос должен проходить через все промежуточные слои
- Возможны проблемы с производительностью из-за дополнительных накладных расходов

**Где используется:**
- Традиционные корпоративные приложения
- ERP-системы
- CRM-системы
- Простые и средние веб-приложения с высокой потребностью в поддержке

**Связь с OSI модель:**
Многослойная архитектура следует принципам модели OSI (7 уровней передачи данных): физический, канальный, сетевой, транспортный, сеансовый, представления, прикладной.

---

### 4. Событийно-ориентированная архитектура (Event-Driven Architecture, EDA)

**Особенности:**
- Система реагирует на события, а не выполняет линейные вызовы
- Компоненты слабо связаны
- Асинхронное взаимодействие через брокер сообщений

**Что такое событие?**
Любое изменение состояния:
- Пользователь зарегистрировался
- Создан заказ
- Файл загружен
- Датчик зафиксировал изменение (IoT)
- Получено сообщение в систему

**Ключевые элементы:**
1. **Producer (Emitter)** — объект, который генерирует событие
2. **Event Bus (Broker)** — маршрутизирует события
3. **Consumer (Listener)** — реагирует на события

**Преимущества:**
- Очень низкая связанность между сервисами
- Высокая масштабируемость
- Асинхронность
- Четкая модульность
- Гибкость (легко добавить новое поведение)
- Продюсеры могут работать, даже если консьюмеры временно недоступны

**Недостатки:**
- Сложная архитектура
- Сложнее отлаживать
- События могут приходить дважды (необходима идемпотентность)
- Нужен надежный брокер сообщений

**Где используется:**
- Системы реального времени
- Финансовые платформы
- Аналитика данных
- IoT-проекты
- Графические интерфейсы и десктопные приложения
- Игровые движки

---

## Паттерн MVC и его вариации

### MVC (Model-View-Controller)

**Компоненты:**
- **Model** — работа с базой данных
- **View** — отображение данных пользователю
- **Controller** — обработка запросов и обновление модели/представления

**В Django: MTV (Model-Template-View)**
- **Model** — остается без изменений
- **Template** — реализация отображения (принцип DRY)
- **View** — логика (то, что в классическом MVC было контроллером)

**Преимущества:**
- Четкое разделение ответственности
- Возможность параллельной разработки UI и бизнес-логики
- Повторное использование компонентов

**Недостатки:**
- Избыточная сложность для простых приложений
- "Жирные контроллеры" — начинающие часто помещают слишком много логики в один контроллер

**Используют:** Django (Python), Ruby on Rails, Spring (Java)

---

## Выбор архитектуры: компромиссы

При выборе архитектуры нужно найти баланс между:

| Критерий | Монолит | Микросервисы/EDA |
|----------|---------|------------------|
| **Скорость разработки** | ✅ Быстро | ❌ Медленнее |
| **Масштабируемость** | ❌ Ограничена | ✅ Высокая |
| **Гибкость** | ❌ Низкая | ✅ Высокая |
| **Сложность** | ✅ Простая | ❌ Сложная |
| **Начальная стоимость** | ✅ Низкая | ❌ Высокая |

**Рекомендации:**
- **От 0 до 1 (MVP):** Монолит или многослойная архитектура
- **Сложные высоконагруженные системы:** Микросервисы или EDA

---

## Реализация Event-Driven Architecture

### Базовая реализация Event Bus на Python

```python
from collections import defaultdict

class EventBus:
    def __init__(self):
        self._listeners = defaultdict(list)
    
    def subscribe(self, event_name, callback):
        """Подписка на событие"""
        self._listeners[event_name].append(callback)
    
    def unsubscribe(self, event_name, callback):
        """Отписка от события"""
        if callback in self._listeners[event_name]:
            self._listeners[event_name].remove(callback)
    
    def emit(self, event_name, **kwargs):
        """Генерация события"""
        for callback in self._listeners[event_name]:
            callback(**kwargs)

# Использование
events = EventBus()

def on_user_registered(username):
    print(f"Пользователь зарегистрирован: {username}")

events.subscribe("user_registered", on_user_registered)
events.emit("user_registered", username="john_doe")
```

**Паттерн проектирования:** Observer (Наблюдатель)

---

### Очереди задач

**Что такое очередь?**
Алгоритм, который упорядочивает процессы (FIFO — First In, First Out).

**Shared Queue с multiprocessing:**

```python
from multiprocessing import Process, Queue
import time

def background_worker(shared_queue):
    while True:
        event = shared_queue.get()
        if event is None:
            break
        print(f"Обработка события: {event}")
        time.sleep(1)

# Использование
shared_queue = Queue()
worker = Process(target=background_worker, args=(shared_queue,))
worker.start()

shared_queue.put({"type": "user_registered", "user": "Alice"})
shared_queue.put(None)  # Сигнал завершения
worker.join()
```

**Альтернативы:**
- **Redis Queue** (rq)
- **Celery** — для асинхронных задач в Django
- **Dramatiq**

---

## Брокеры сообщений

### RabbitMQ

**Характеристики:**
- Гарантированная доставка
- Роутинг по ключам событий
- ~50 сообщений/сек
- Очереди исчезающие (transient)

**Пример использования:**

```python
import pika
import json

# Listener (Consumer)
def callback(ch, method, properties, body):
    data = json.loads(body)
    print(f"Получено событие: {method.routing_key}")
    print(f"Данные: {data}")

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue='user_notifications')

channel.basic_consume(
    queue='user_notifications',
    on_message_callback=callback,
    auto_ack=True
)

channel.start_consuming()

# Publisher
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

message = json.dumps({"user_id": 123, "action": "registered"})
channel.basic_publish(
    exchange='',
    routing_key='user_notifications',
    body=message
)

connection.close()
```

**Когда использовать:**
- Микросервисы
- Фоновая работа
- Средненагруженные системы

---

### Apache Kafka

**Характеристики:**
- Потоковая платформа
- Сотни тысяч событий/сек (в 10 раз производительнее RabbitMQ)
- Очереди постоянные (persistent) — используется логирование
- Подходит для больших объемов данных

**Пример использования:**

```python
from kafka import KafkaConsumer, KafkaProducer
import json
import os

# Consumer (Listener)
consumer = KafkaConsumer(
    'user_events',
    bootstrap_servers=os.getenv('KAFKA_BROKER', 'localhost:9092'),
    value_deserializer=lambda m: json.loads(m.decode('utf-8'))
)

for message in consumer:
    print(f"Событие: {message.value}")

# Producer (Publisher)
producer = KafkaProducer(
    bootstrap_servers=os.getenv('KAFKA_BROKER', 'localhost:9092'),
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

producer.send('user_events', {
    'event': 'user_registered',
    'user_id': 123
})
```

**Когда использовать:**
- Системы реального времени
- Big Data аналитика
- Финансовые платформы
- Высоконагруженные системы

---

### Сравнение RabbitMQ vs Kafka

| Критерий | RabbitMQ | Kafka |
|----------|----------|-------|
| **Производительность** | ~50 сообщений/сек | ~500+ сообщений/сек |
| **Тип очередей** | Transient (исчезающие) | Persistent (постоянные) |
| **Использование** | Микросервисы, фоновые задачи | Streaming, Big Data, аналитика |
| **Роутинг** | ✅ Есть | ✅ Есть |
| **Сложность** | Средняя | Выше |

---

## API и стандарты обмена данными

### 1. REST (Representational State Transfer)

**Особенности:**
- Архитектурный стиль, а не протокол
- Набор принципов для обмена данными
- Client-Server разделение
- Stateless (без сохранения состояния)

**Принципы:**
- Использование HTTP методов (GET, POST, PUT, DELETE)
- Ресурсо-ориентированные URL
- Стандартные коды ответов

**Преимущества:**
- Простота
- Широкая поддержка
- Кэширование

**Недостатки:**
- Over-fetching (получение лишних данных)
- Under-fetching (недостаток данных, нужны дополнительные запросы)

---

### 2. GraphQL

**Особенности:**
- Язык запросов для API
- Клиент запрашивает только нужные поля
- Один endpoint для всех запросов

**Преимущества:**
- Гибкость запросов
- Нет over-fetching/under-fetching
- Сильная типизация

**Недостатки:**
- Сложнее кэширование
- Требует специальных инструментов

---

### 3. gRPC (Google Remote Procedure Call)

**Особенности:**
- Удаленный вызов процедур
- Синхронные вызовы с высокой скоростью
- Использует Protocol Buffers

**Когда использовать:**
- Нужна высокая скорость
- Не требуется хранение событий
- Межсервисная коммуникация

---

## Инструменты в Django для EDA

### 1. Сигналы (Signals)

Django предоставляет встроенные сигналы:
- `post_save` — после сохранения
- `pre_delete` — перед удалением
- `m2m_changed` — изменение many-to-many связей

```python
from django.db.models.signals import post_save
from django.dispatch import receiver

@receiver(post_save, sender=User)
def user_registered_handler(sender, instance, created, **kwargs):
    if created:
        print(f"Новый пользователь: {instance.username}")
        # Отправка email, создание профиля и т.д.
```

---

### 2. Celery

Асинхронная обработка задач:
- Фоновые задачи
- Периодические задачи (cron-like)
- Использует брокер (Redis, RabbitMQ)

```python
from celery import shared_task

@shared_task
def send_welcome_email(user_id):
    user = User.objects.get(id=user_id)
    # Отправка email
    print(f"Email отправлен: {user.email}")
```

---

### 3. Webhooks

HTTP callbacks для уведомления внешних систем:
- Интеграция с платежными системами (Stripe)
- Telegram API
- GitHub webhooks

---

## Практические примеры EDA

### Пример: E-commerce система

**Событие:** Пользователь создал заказ

**Реакции:**
1. **Notification Service** — отправляет email/SMS подтверждение
2. **Payment Service** — инициирует платеж
3. **Analytics Service** — обновляет метрики и дашборды
4. **Inventory Service** — резервирует товары на складе
5. **Shipping Service** — создает задачу на доставку

**Преимущества подхода:**
- Сервисы не знают друг о друге
- Легко добавить новую функциональность
- Каждый сервис масштабируется независимо

---

### Пример: Banking система

**Событие:** Поступление средств на счет

**Проверки:**
1. Если сумма < порогового значения → зачислить автоматически
2. Если сумма ≥ порогового значения → отправить на финансовый мониторинг
3. Уведомить клиента о зачислении
4. Обновить баланс в real-time

---

## Дополнительная информация

### FastAPI и асинхронность

**Особенности FastAPI:**
- Асинхронный фреймворк
- Использует ASGI вместо WSGI
- Встроенный Swagger UI
- Валидация через Pydantic
- Полностью кастомная структура (преимущество и недостаток)

**Когда использовать:**
- Высоконагруженные API
- Микросервисы
- Комбинация с Django (Django — основа, FastAPI — для API)

---

### Аналитика и мониторинг

**Метрики для отслеживания:**
- Количество заказов
- Средний чек
- Конверсия
- Скорость доставки
- Доход по периодам

**Инструменты:**
- Prometheus + Grafana
- ELK Stack (Elasticsearch, Logstash, Kibana)
- Datadog
- Custom дашборды

---

## Итоговые рекомендации

### Для стартапов (MVP):
✅ Монолит (Django)
✅ REST API
✅ Простая архитектура

### Для средних проектов:
✅ Многослойная архитектура
✅ REST или GraphQL
✅ Celery для фоновых задач

### Для высоконагруженных систем:
✅ Микросервисы
✅ Event-Driven Architecture
✅ Kafka или RabbitMQ
✅ gRPC для межсервисной коммуникации
✅ Kubernetes для оркестрации

---

## Ключевые выводы

1. **Не существует универсальной архитектуры** — выбор зависит от задачи
2. **Начинайте с простого** — монолит для MVP, затем рефакторинг
3. **Event-Driven подходит для сложных систем** с высокими требованиями к масштабируемости
4. **Брокеры сообщений** — ключевой компонент EDA (RabbitMQ или Kafka)
5. **Слабая связанность** — главное преимущество событийной архитектуры
6. **Сложность отладки** — главный недостаток асинхронных систем

---

## Практическое задание

### Задача 1: Создать Event Bus
Реализовать собственную шину событий с методами:
- `subscribe(event_name, callback)` — подписка
- `unsubscribe(event_name, callback)` — отписка
- `emit(event_name, **kwargs)` — генерация события

### Задача 2: Интеграция с RabbitMQ
Создать Publisher и Listener для обработки событий через RabbitMQ.

### Задача 3: Очередь задач
Реализовать систему обработки задач с использованием `multiprocessing.Queue`.

---

## Дополнительные ресурсы

- [Martin Fowler — Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html)
- [RabbitMQ Tutorials](https://www.rabbitmq.com/getstarted.html)
- [Apache Kafka Documentation](https://kafka.apache.org/documentation/)
- [Django Signals](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Celery Documentation](https://docs.celeryproject.org/)