# Завдання 9: Написати програму для кешування результатів функції, щоб покращити продуктивність.
# 1.	Створити функцію memoize, яка приймає функцію та повертає нову функцію, що зберігає результати викликів.
# 2.	Використати цю функцію, щоб кешувати результати обчислень (наприклад, факторіал або фібоначі).
from typing import Callable, Dict, Any, Tuple


def memoize(func: Callable) -> Callable:
    """
    Декоратор для кешування результатів функції.
    Параметри:
        func (Callable): Функція, для якої потрібно кешувати результати.

    Повертає:
        Callable: Обгортка навколо оригінальної функції з кешуванням результатів.
    """
    cache: Dict[Tuple[Any, ...], Any] = {}  # Результати

    def wrapper(*args: Any, **kwargs: Any):
        # Створення унікального ключа на основі аргументів функції.
        key = (args)
        # Якщо результат вже є в кеші, повертаємо його
        if key in cache:
            print(f"Використовуємо кешований результат для {args}...")
            return cache[key]

        # Інакше, обчислюємо результат, зберігаємо його в кеші і повертаємо
        result = func(*args, **kwargs)
        cache[key] = result
        print(f"Обчислюємо результат для {args}...{result}")
        return result

    return wrapper


@memoize
def factorial(n):
    """
      Обчислює факторіал заданого числа.

    Параметри:
        n (int): Ціле число, для якого потрібно обчислити факторіал.

    Повертає:
        int: факторіал числа, якщо n >= 0
        str: повідомлення про помилку, якщо n < 0
    """
    if n < 0:
        return "Факторіал не визначений для від'ємних чисел"
    if n == 0:
        return 1
    return n * factorial(n - 1)


# Тестуємо функцію факторіалу
print("Перше обчислення:")
print(f"Факторіал 5: {factorial(5)}")

print("\nДруге обчислення:")
print(f"Факторіал 3: {factorial(3)}")  # Це значення вже в кеші з попереднього виклику

print("\nТретє обчислення:")
print(f"Факторіал 5: {factorial(5)}")  # Весь ланцюжок від 5 до 1 уже в кеші
