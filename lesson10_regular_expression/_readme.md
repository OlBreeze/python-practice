Вот структурированная лекция по теме **регулярных выражений (RegEx)** в формате Markdown с дополнениями и проверенной информацией из открытых источников.

---

# Лекция: Регулярные выражения (Regular Expressions)

**Повестка (Agenda):**

1. Введение в регулярные выражения
2. Что такое регулярные выражения (RegEx) и для чего они нужны
3. Примеры использования регулярных выражений в повседневных задачах
4. Основные преимущества и недостатки
5. Базовые символы и конструкции регулярных выражений

   * Литералы и метасимволы: `.`, `^`, `$`, `*`, `+`, `?`, `{}`, `[]`, `()`
   * Классы символов: `[a-z]`, `[A-Z]`, `[0-9]`, `\d`, `\w`, `\s` и их негативные варианты `\D`, `\W`, `\S`
   * Группирование и альтернативы: `()` и `|`
   * Якоря: начало и конец строки `^` и `$`
6. Расширенные возможности регулярных выражений

   * Квантификаторы: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}`
   * Жадные и ленивые квантификаторы: `*?`, `+?`, `??`
   * Символьные наборы и диапазоны `[abc]`, `[a-z]`
7. Практика создания регулярных выражений

   * Инструменты для тестирования: например, [regex101.com](https://regex101.com/)
   * Как читать и понимать сложные регулярные выражения
8. Выводы и практика
9. Вопросы и ответы (Q\&A)

---

## 1. Введение в регулярные выражения

Регулярные выражения — это мощный инструмент для работы с текстом, который позволяет задавать шаблоны поиска, замены или извлечения фрагментов текста, соответствующих определённым критериям.
Они используются почти во всех языках программирования и подходят для: поиска строк по шаблону, проверки формата, извлечения данных и автоматизации обработки текста. ([GeeksforGeeks][1])
В Python поддержка регулярных выражений реализована через модуль `re`. ([Dremendo][2])
Важно понимать, что хотя регулярные выражения чрезвычайно полезны, они также могут быть трудны для понимания и поддержки, особенно при сложных шаблонах. ([arXiv][3])

---

## 2. Что такое регулярные выражения (RegEx) и для чего они нужны?

Регулярное выражение (RegEx) — это последовательность символов, описывающая шаблон поиска. Примеры задач, где используют RegEx:

* Поиск всех вхождений заданного шаблона в тексте.
* Замена фрагментов текста, соответствующих шаблону, на другой текст.
* Валидация текста на соответствие шаблону (например, формат e-mail или номера телефона).
* Извлечение из текста фрагментов, соответствующих шаблону.
  Эти возможности делают RegEx ценным инструментом в текстовой обработке, логах, парсинге, веб-скрапинге. ([GeeksforGeeks][1])

---

## 3. Примеры использования регулярных выражений в повседневных задачах

* Проверка правильности e-mail адреса (например, `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`).
* Поиск в тексте ключевых слов или шаблонов (например, телефонных номеров, URL).
* Замена формата даты (например, из `DD/MM/YYYY` в `YYYY-MM-DD`).
* Извлечение данных из лог-файлов или html-страниц.
* Автоматизация обработки больших текстовых массивов: фильтрация, очистка, извлечение.
  Такие примеры подробно рассматриваются в руководствах по RegEx в Python. ([Dremendo][2])

---

## 4. Основные преимущества и недостатки

**Преимущества:**

* Позволяют описывать очень сложные шаблоны поиска/соответствия.
* При правильном использовании — быстрые и эффективные (реализации оптимизированы).
* Поддерживаются во многих языках и инструментах — универсальность.

**Недостатки:**

* Требуют обучения и практики — сложно сразу разобраться.
* В больших или плохо документированных шаблонах легко допустить ошибку, что приведёт к неверной работе. ([arXiv][3])
* Сложные RegEx трудно читать и поддерживать — особенно в командной среде.
  Поэтому важно использовать их обдуманно, документировать шаблоны и по возможности упрощать задачу, если можно обойтись без сложного регулярного выражения.

---

## 5. Базовые символы и конструкции регулярных выражений

### Литералы и метасимволы

* Литералы: обычные символы (буквы, цифры, знаки пунктуации) — соответствуют самим себе.
* Метасимволы: символы с особым значением в RegEx. Например:

  * `.` — любой символ, кроме символа новой строки. ([Google for Developers][4])
  * `^` — начало строки. ([Real Python][5])
  * `$` — конец строки.
  * `*` — 0 или более повторений предыдущего символа или группы.
  * `+` — 1 или более повторений.
  * `?` — 0 или 1 повторение.
  * `{n}` — ровно n повторений.
  * `{n,}` — n или более повторений.
  * `{n,m}` — от n до m повторений. ([Dremendo][2])
  * `[]` — символьный набор (набор символов допускаемых в данном месте).
  * `()` — группировка выражений или подшаблон.

### Классы символов

* `[a-z]` — все маленькие буквы латинского алфавита.
* `[A-Z]` — все большие буквы латинского.
* `[0-9]` — все цифры.
* `\d` — цифра (эквивалент `[0-9]`) в большинстве реализаций. ([Google for Developers][4])
* `\w` — буква, цифра или подчёркивание (эквивалент `[a-zA-Z0-9_]`).
* `\s` — пробельный символ (пробел, табуляция, новая строка).
* Их негативные формы: `\D` (не цифра), `\W` (не слово), `\S` (не пробел) — соответственно. ([Dremendo][2])

### Группирование и альтернативы

* `()` — группируют часть выражения; внутри можно указывать подшаблоны.
* `|` — логическая альтернатива (или). Пример: `(cat|dog)` — либо “cat”, либо “dog”.
* Якоря:

  * `^` — начало строки.
  * `$` — конец строки.
    Пример: `^Hello` — строка, начинающаяся с “Hello”. ([Python Basics][6])

---

## 6. Расширенные возможности регулярных выражений

### Квантификаторы

* `*` — 0 или более.
* `+` — 1 или более.
* `?` — 0 или 1.
* `{n}` — ровно n.
* `{n,}` — n или более.
* `{n,m}` — от n до m. ([Dremendo][2])

### Жадные vs ленивые квантификаторы

* Жадные (greedy): `*`, `+`, `?`, `{n,m}` — пытаются захватить как можно больше символов.
* Ленивые (lazy) версии: `*?`, `+?`, `??`, `{n,m}?` — пытаются захватить как можно меньше.

### Символьные наборы и диапазоны

* `[abc]` — один символ: либо ‘a’, либо ‘b’, либо ‘c’.
* `[a-z]` — диапазон букв от ‘a’ до ‘z’.
* Комбинации: `[A-Za-z0-9]` и др.

### Другие расширенные конструкции (упомянуть)

* Префикс `r` для строкового литерала (raw string) — рекомендуется при написании шаблонов RegEx в Python, чтобы не дублировать экранирование. ([RegexOne][7])
* Флаги (например, `re.IGNORECASE`, `re.MULTILINE`, `re.DOTALL`), именованные группы, позитивный/негативный просмотр вперёд/назад (lookahead/lookbehind) — они могут быть покрыты в продвинутом материале. ([Real Python][5])

---

## 7. Практика создания регулярных выражений

### Инструменты

Для тестирования и отладки регулярных выражений отлично подходит онлайн-инструмент regex101 (выберите flavour “Python” или “PCRE”), где можно вводить шаблон и текст, видеть совпадения, смотреть подсказки. Пользователи отмечают его как один из лучших. > “Regex101.com is a great tool for live testing and learning how regex works” ([Reddit][8])

### Как читать и понимать сложные выражения

Пример: шаблон для e-mail: `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
Разбор:

* `^` — начало строки
* `[a-zA-Z0-9._%+-]+` — один или более символов: буквы, цифры, точки, подчёркивания, проценты, плюсы или минусы
* `@` — буквальный символ @
* `[a-zA-Z0-9.-]+` — один или более символов: буквы, цифры, точка или дефис
* `\.` — точка (экранированная)
* `[a-zA-Z]{2,}` — две или более буквы (например, “com”, “org” и др.)
* `$` — конец строки
  Хорошая установка: разбивать выражение на логические части, тестировать их отдельно, использовать онлайн-инструмент, двигаться от простого к сложному.
  Также полезно помнить, что читаемость важна — документируйте шаблоны, особенно если они сложные.

---

## 8. Выводы и практика

* Регулярные выражения — чрезвычайно мощный инструмент для работы с текстом и шаблонами.
* Несмотря на свою мощь, они требуют практики и дисциплины: неправильный шаблон может привести к ошибкам или плохой производительности.
* Желательно начинать с простых шаблонов, использовать тестовые инструменты, постепенно усложнять.
* В командной разработке важно документировать и, по возможности, снабжать комментариями сложные шаблоны, чтобы другие могли понимать.
* Практическое задание:

  1. Составьте шаблон, который проверяет формат телефонного номера (например, +38 (0xx) xxx-xx-xx).
  2. Попробуйте извлечь все e-mail адреса из текста с помощью `re.findall`.
  3. Напишите шаблон, который находит все HTML-тэги (например, `<tag>…</tag>`) и извлекает имя тега и содержимое.
  4. Используйте regex101.com, включите “Explain” или “Detailed” режим, чтобы видеть разбор вашего шаблона.
* Вопросы и ответы: обсудите случаи, когда *не стоит* использовать RegEx: например, когда задача слишком сложна или можно решить проще обычными строковыми методами.

---

[1]: https://www.geeksforgeeks.org/python-regex/?utm_source=chatgpt.com "Python RegEx - GeeksforGeeks"
[2]: https://www.dremendo.com/python-programming-tutorial/python-regular-expression?utm_source=chatgpt.com "Regular Expression in Python Programming | Dremendo"
[3]: https://arxiv.org/abs/2303.02555?utm_source=chatgpt.com "Regexes are Hard: Decision-making, Difficulties, and Risks in Programming Regular Expressions"
[4]: https://developers.google.com/edu/python/regular-expressions?utm_source=chatgpt.com "Python Regular Expressions  |  Python Education  |  Google for Developers"
[5]: https://realpython.com/regex-python/?utm_source=chatgpt.com "Regular Expressions: Regexes in Python (Part 1) – Real Python"
[6]: https://pythonbasics.org/regular-expressions/?utm_source=chatgpt.com "Regular Expressions - Python Tutorial"
[7]: https://regexone.com/references/python?utm_source=chatgpt.com "RegexOne - Learn Regular Expressions - Python"
[8]: https://www.reddit.com/r/learnpython/comments/13paj8o?utm_source=chatgpt.com "Regex puzzle"
